能认识字节码跟类型码，能对python的整体流程更加的清晰。

## 认识字节码的契机(从哪里看见这个名词)
在阅读《流畅的python》第二章序列构成的数组，小节一个关于+=的谜题，示例2-16`s[a] = b背后的字节码`，代码示例：
```python
>>> dis.dis('s[a] += b')
  0           0 RESUME                   0

  1           2 LOAD_NAME                0 (s)
              4 LOAD_NAME                1 (a)
              6 COPY                     2
              8 COPY                     2
             10 BINARY_SUBSCR                    1️⃣
             20 LOAD_NAME                2 (b)
             22 BINARY_OP               13 (+=)  2️⃣
             26 SWAP                     3
             28 SWAP                     2
             30 STORE_SUBSCR
             34 LOAD_CONST               0 (None)3️⃣
             36 RETURN_VALUE
```

^c7db4b

dis能反汇编对象x，就是`s[a] += b`的字节序列，然后再呈现出来。基于python的语言设计，在编译过程中会有转成汇编语言这一步，会从底层调用各种函数指令来完成任务。参照[Java字节码](https://zh.wikipedia.org/wiki/Java%E5%AD%97%E8%8A%82%E7%A0%81)的描述，python也是通过字节码去调用各种函数来执行一个表达式或者函数。这里所说的**各种函数**，就是RESUME, LOAD_NAME, COPY等。 并且在反汇编这个模块上，python仍然在不断更新。可参照[dis - Python 字节码反汇编器](https://docs.python.org/zh-cn/3/library/dis.html#module-dis)
## 字节码到底是什么
概括成一句话就是：字节码是调用汇编函数的指令。
因为我没有学过c/c++，我并不清楚他们的详细内容。
## 可以做什么
我们并不能完全相信我们能“看懂”的代码，而忽视了背后所更精细的运算过程。
在《流畅的python》中，提出了关于 "+=" 运算符的谜题：
```python
>>> t = (1, 2, [30, 40])
>>> t[2] += [50, 60]
```

一个经典的不可变序列里含有可变序列进行运算的问题。

> [!NOTE] question
> 到底会发生下面四种情况中的哪种？
> a.t会变成(1, 2, [30, 40, 50, 60])。
> b.因为tuple不支持对它的元素赋值，所以会抛出TypeError异常。
> c.以上两个都不是。
> d.a和b都会发生

我看到这个题以后也自然想到了第八章中元组的相对不可变性，然后忽略了元组不可变性的根本，导致选了a，(后来经过反思，有点就新忘旧的意思。不过也是好事，说明我学完并没有忘记)然而实际上这道题的答案是d，a和b都会发生！

再往下输出一行t
```python
>>> t = (1, 2, [30, 40])
>>> t[2] += [50, 60]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment
>>> t
(1, 2, [30, 40, 50, 60])
```

^8fea87

无论从逻辑上分析，还是看代码的运行都跟结果对不上，为了更深入、更详细的理解整个过程，进而进入了上面所提到的`dis.dis()`反编译函数。
再回到最上面关于反编译的代码块:
![[字节码#^c7db4b]]

实际上，运算是用栈实现的，因为还没有完全学动这个地方，就不细说了。
一个增量赋值的运算是**先将右值计算完然后再让左值加**，对应了BINARY_OP -> STORE_SUBSCR的部分，又涉及到[[引用]]的一些小知识，也是因为引用的原因，才导致虽然出了bug但是仍然将列表更新了。

### 小节
所以，字节码作为底层中汇编与反汇编的执行命令而存在，正是有了它们，所有学习python(当然例如java也有字节码)的人能实现更进一步的确定、了解在解释器下到底发生了什么事导致了意想不到的结果。

