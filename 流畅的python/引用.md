引用的设计，可以说是面向对象编程的一大特点。庞大的python语言框架正式由引用机制来实现的。虽然我没有看过CPython中的引用是如何实现的，但是我猜一定是指针，也可能是引用。如果不了解指针是什么，emmmm，我承认确实会抽象一些。

先明确两个名词：变量，对象
左值是变量，右值是对象，赋值运算中：变量 = 对象。(=是赋值运算符)
# python变量中的指针现象

## 不是盒子
参照《流畅的python》第八章第一节 变量不是盒子，来思考一下这个事情。
```python
>>> a = [1, 2, 3]
>>> b = a
>>> a.append(4)
>>> b
 [1, 2, 3, 4]
```
按c语言中的习惯，在b被赋予a的值时，b获得了一个`[1, 2, 3]`的列表，且与a的不同。就像两个“盒子”里面装的东西一样，这显然解释不了b为什么也会被添加一个元素的现象。如果a和b都是指向这个列表的指针呢？问题突然就明朗起来了。应该把变量(准确的说是变量名)当成便利贴。(没错，就是引用) a和b同时指向了同一个列表，而不是b重新创建了一个与其相同的列表或者说副本，而a和b的关系就像一个人的两个名字(外号)。在python中叫：**引用**。

> [!NOTE] 阿巴阿巴
> 实际上，它只是表现的很像指针，但与指针又不完全相同，如果学过c++的话，它其实更像引用，只是c++的引用不能修改。比如，指针也拥有它自己的内存来存放，但a和b的地址就都是那个列表的地址，可以用id()来测试。我想表达的就是，python是基于c来写的，引用表现的真的很像指针，而又凌驾于指针之上。好吧，这段可以忽略。

还有比较重要的是，在赋值操作中可以从右到左看，刚好与c语言相反，我也想写一个例子的，但是我觉得这个例子不太好。总之，从右到左看。

## 一些引用规则
这里的一些内容是我在别的书上看见的，我对一些规则一直有些不理解。
*首先是关于原子性数据的：*
**交互模式下**，变量值整数在[-5, 256]之间时，所有值相同的数字都共用一个内存地址，即引用的对象相同。
```python
>>> a = [-5, 256, 257]
>>> b = [-5, 256, 257]
>>> id(a[0]), id(a[1]), id(a[2])
(140730724685280, 140730724693632, 1741382777136)
>>> id(b[0]), id(b[1]), id(b[2])
(140730724685280, 140730724693632, 1741383821424)
```

在这个范围外的整数或者其他类型，交互模式下，同一条语句中同值对象共用一个内存地址
```python
>>> x = [66666, 66666]
>>> y = [66666, 66666]
>>> id(x) == id(y)
False
>>> id(x[0]), id(x[1])
(1741383821456, 1741383821456)
>>> id(y[0]), id(y[1])
(1741383821680, 1741383821680)
```
为了节省内存，在**同一程序**中，与**交互模式**仍有不同。在同一程序下，同值变量会使用统一内存地址。
```python
x = 1000000
y = 1000000
print(id(x), id(y))
a = [10000, 10000]
b = [10000, 10000]
print(id(a), id(b))
print(id(a[0]), id(b[0]))

2644042643696 2644042643696
2644043431872 2644049091712
2644043074448 2644043074448
```

### 关于序列：
序列又分为可变序列与不可变序列，这一部分可能要绕一些
序列用列表举例，即使是两个组成元素完全相同(就来引用的对象都相同)的列表，也仍然是不同的，可以见上面代码块中第二个print例子输出的a，b列表的内存，只有当形如
```python
>>> a = [1, 2, 3]
>>> b = a
```
这种才会实现引用传递的现象，否则是两个同值不同名的对象。强烈推荐一个python工具：
[Python Tutor](https://pythontutor.com/)，它能自己编辑代码来查看序列中的各种引用关系，强烈推荐。
#### 补充
序列或者说非原子属性，在最开始创建的时候，完全相同内容的序列也会是两个不同的对象，只有在赋值运算符`=`时会出现引用传递的现象，其他情况下均是不同的对象（即使是相同内容）。

## is、==
python的条件判断基本上都是基于这两个来判断的，`is`比较对象的标识,`==`比较的是值。书中有个地方让我很困惑：

> [!NOTE] 原文
> a == b是语法糖，等同于`a.__eq__(b)`。继承自object的`__eq__`方法比较两个对象的ID，结果与is一样。
### `object.__eq__`

> [!smile] 语法糖
> The correspondence between operator symbols and method names is as follows: `x<y` calls `x.__lt__(y)`, `x<=y` calls `x.__le__(y)`, `x==y` calls `x.__eq__(y)`, `x!=y` calls `x.__ne__(y)`, `x>y` calls `x.__gt__(y)`, and `x>=y` calls `x.__ge__(y)`

在python document中提到了`object.__eq__()`的默认写法：以`x==y`为例，`True if x is y else NotImplement`。所以在默认下其实就是`x is y`比较的也确实是id。可基于灵活的语法，一般大家都会为`__eq__()`加上其他的功能使得它更能实现对象的逻辑，就出现了比较值的形式，也是用的最多的一个形式。
以此衍生出来的深、浅赋值，一些规范化限制，都是基于此展开的。

## 总结
当序列以变量名进行赋值时，实际上是在重复引用，没有创建新的对象；而以具体列表赋值变量时，每次都会重新创建一个对象，形如`a = [1, 2, 3]`,[1, 2, 3]就是具体列表的意思。还有一种方法`list(a)`，这种方法得到一个a的副本。后面我们再来说副本是什么。
所以就会有一个特别有趣的现象，一个列表以各种别名被到处操作。

说完赋值，再来看看运算后的序列，引用会如何变化。
针对于可变序列和不可变序列，或者扩大一下范围，可变对象跟不可变对象(其实我就是想把整数带上)，也有不同的结果产生。

```python
def add(a, b):
	a += b
	return a

>>> x = 1
>>> y = 2
>>> add(x, y)
3
>>> x, y
(1, 2)
# x的值在累加以后并没有变化
>>> x = [1, 2]
>>> y = [3, 4]
>>> add(x, y)
[1, 2, 3, 4]
>>> x, y
([1, 2, 3, 4], [3, 4])
# 列表x在累加后变成了拼接后的列表
>>> x = (1, 2)
>>> y = (3, 4)
>>> add(x, y)
(1, 2, 3, 4)
>>> x, y
((1, 2), (3, 4))
# 元组作为不可变序列，没有发生变化
```
从结果总结就是，在增量赋值操作出现时，如果是可变序列，就会就地改变列表元素，即__iadd__，对于引用它的变量不会更改，是本体出现了改变。而不可变序列，因为没有魔法函数__iadd__的存在，在增量赋值操作中，会创建一个新的对象，内容为运算的结果，然后将变量的引用指向新的对象。整型对象就更不用说了，本身就不可变，所以引用会改变。
[[序列的内置函数们|内置函数详见]]

## 规范化设计
### python的函数参数
python支持的是*共享传参*(call by sharing)，共享传参指函数参数是各个实参中各个引用的*副本*。

> [!NOTE] 什么是副本
> 副本是复制的结果（默认为浅复制），且一般只对序列对象讨论副本问题，因为单值对象讨论没有意义。

```python
>>> l1 = [1, 2, [3, 4, 5], (6, 7, 8)]
>>> l2 = list(l1)
```
l2是l1浅复制的副本，它们两具有相同的值，但并不是指向同一个列表(大列表)，既`id(l1) is not id(l2)`，但内部对列表，元组的引用是相同的，既对于列表`[3, 4, 5]`，`l1[2], l2[2]`分别是它们的两个别名。可以理解成l1、l2分别是相同对象的地址记录，但l1、l2地址又不同。当列表内部出现*自加、自减等*运算的序列比如列表时，对其中一个的修改会作用于另外一个，而对元组的操作则不会，因为`l1[3] += (9, 10)`的结果是对一个新元组的引用，原来的元组`(6, 7, 8)`仍然不变。
归根结底还是类型设计上的区别导致的，这里面只有list有`__iadd__`，故引用不会改变，两个大列表会同时改变。

### 不要使用可变序列作为参数
如上所谈，可变序列作为参数时，无论被调用多少次都是对同一个列表的引用，会出现乱套。

### 应用场景(bug场景)

[[元组，具名元组#^de5754|元组相对可变性]]

## 问题
如何实现对本地变量的引用