1. `printf, scanf`对`int`型变量的格式字符只有`%d`，没有大写。
2. 只有十六进制`%x, %X`,指数型`%e, %E`,宽度简短的浮点型`%g, %G`,是有大写的，其他的格式字符都没有
3. `printf("%.4f")`是四舍五入的，不是向下取整。
4. 对自增运算符`++i, i++`的区别，`++i`是在出现他的地方，将i的值加一然后参与表达式的计算，而`i++`是在`下一次`出现i的地方，将值变成i+1
```c++
int i = 6;
if (i++ > 5)
	printf("%d", i);
else 
	printf("%d", i--);
```

结果是`7, 5`
5. `sizeof(可以放类型关键字)`，sizeof() -> unsigned long long int
6. `printf("%x, %o")`对十六进制、八进制的输出，并不会输出十六进制('0x'),八进制('0')的符号
7. 位运算`>>, <<`
> [NOTE] 位运算符
> 结合方向：自左向右
> <<是左移，>>右移，尖的一边是移动方向
> 对数据的二进制进行操作，比如10001,右移3，就是整体往后面推3格变成10也就是2

8. for(;;)什么不写就视为真
9. 二维数组`a[][3]`的命名细节：
10. strlen -> int 统计的长度不包含`\0`.
11. 一维数组的定义方式：类型说明符，数组名，[常量表达式]
- 常量表达式:包含整型常量`[1]`,整型常量表达式`[1+2*3]`,符号常量(宏定义)
12. `scanf()`不能获取空格字符，`gets()`可以获得空格字符
13. strcmp()的返回值
14. 指针数组的定义
```c
int a[10]; // 整型数组
int* b[10]; // 整形指针数组
// 字符串同理
```
15. 关于字符数组、字符指针对字符串的定义
```c
char str[10] = "Cavalry"; // 如果是数组的话只能这么定义
// 字符串同样带有地址，如
printf("%p", "asdlzcjk");
>>> 00007FF7D27EAD28
------------------------------------
// 所以，两个都有地址的变量是不能进行赋值的，既
char str[10];         ×
str = "Cavalry"; // 是错误的
在定义了str[10]以后，它作为一个变量就已经被分配地址了
而下一步令 str = "Cavalry"相当于是两个地址的赋值，显然就出错了
如果想要用定义与初始化分开的操作只能用指针
-----------------------------------
char *p;
p = "Cavalry";        √
因为定义*p时，没有指定变量，此时p是野指针，然后被字符串的首字母地址赋值。
```
16. `*的优先级比计算运算符要高，且是从右向左`，体现在`*(p+1) <=> *p+1`是等价的，因为是从右开始，都要地址+1.
17. 内存单元到底是什么，字节，位数又是什么
18. 函数指针与指针函数
19. 指针数组的声明
```c
A. int *p[2];
B. int (*p)[2];
C. typedef int* intPtr; intPtr p[2];
```

