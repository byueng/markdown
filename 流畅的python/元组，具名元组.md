元组是python中常用序列之一，也是不可变序列之一。
它的结构是小括号`(a, b, c)`这种形式，因为是不可变序列，跟列表相比一些序列操作不会支持一些函数。**可以说它就是一个比列表功能稍微少一些的一个列表**。
# 不可变性
在[[序列的内置函数们]]能做一个对比发现，一切与**计算**有关的内置函数，元组都没有，只能作为单纯存储数据的序列。一旦被创建出来，里面元素的位置，大小，数量都不支持修改。 元组更多是作为存储数据来使用，相应的它会比列表的速度快上那么一些。

考虑到元组的内容实在太少了，我就来扩展一下：**元组的相对可变性**

# 相对可变性

^de5754
既然解释器就像一个严格的毕设导师，要求你的论文必须使用CNN的骨干网络去写，可是你就像用Transformer的骨干网络实现该怎么办？
我有一计偷天换日：不修改xxxxNet.py的名字，直接修改它的内容。(前提是你的导师不会一行行让你调试代码)形如披着羊皮的狼。
同样，我们绕过选取元组中的一个元素(不以元组切片的方式去操作元素)，转而直接去修改元素的引用对象，也能达成修改元组的操作。
如果对引用不熟悉，我认为有必要看一下这篇关于[[引用]]的笔记。
只有当可变序列作为元组中的元素时，才会有相对可变性出现。这种问题会十分少见，但是很有意思。

我们举个例子![[字节码#^8fea87]]
这个代码出现在另一篇笔记[[字节码]]中，在这里讨论的跟字节码没有关系。
在这里，`t[2]`是列表`[30, 40]`的别名，这里因为有bug看的不舒服，我来修改一下。
```python
>>> a = (1, 2, [3, 4])
>>> b = a[2]
>>> b += [5, 6, 7]
>>> a
(1, 2, [3, 4, 5, 6, 7])
```
因为元组不提供__iadd__这种**就地增值赋值**的方法，可以利用引用的特点，对它另一个不在元组中的别名操作，那么改变的结果作用在对象`[3, 4]`上，实现了对元组内容的改变。

## 具名元组(namedtuple)
具名数组需要用到`collections`来实现，意思就是元组中的每一个变量都有名称。所以与其说是具名元组，不如说是**只有属性的简易类**
```python
from collections import namedtuple
>>> from collections import namedtuple
>>> Person = namedtuple("Person", ["name", "gender"])
>>> me = Person("gzh", "male")
>>> me
Person(name='gzh', gender='male')
```
同样，具名元组也是不可变的。
```python
>>> dir(Person)
['__add__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getnewargs__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__module__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__rmul__', '__setattr__', '__sizeof__', '__slots__', '__str__', '__subclasshook__', '_asdict', '_field_defaults', '_fields', '_fields_defaults', '_make', '_replace', 'count', 'gender', 'index', 'name']
```
可以看到并没有形如`__iadd__`这样支持就地增值赋值的方法。